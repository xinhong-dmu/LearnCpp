#include<iostream>
using namespace std;

//泛型编程思想――利用模板技术实现
//模板――建立通用的模具，大大提高复用性
//模板的特点：1.目标不可以直接使用，他只是一个框架；2.模板的通用并不是万能的

//模板机制1――函数模板
//函数模板的返回值类型和输入的形参数据类型可以先不具体写，用一个虚拟的类型代替

//函数模板语法：
//template<typename(可用class替换)  通用数据类型  (可用大写字母一般为T替换),typename Q>
//第二行写函数声明，把数据类型换成T即可；


//函数模板
template<typename T>//声明模板后面紧跟着的T不要报错
void swap0(T &a, T &b)
{
	T temp = a;
	a = b;
	b = temp;
}


//使用函数模板方式1――自动类型推导――swap0(a, b);
void test00()
{
	int a = 10;//给出数据后自动判断数据类型
	int b = 20;//数据类型必须一致
	//必须给出数据类型T
	swap0(a, b);
}
//使用函数模板方式2――显示指定类型――中间加<数据类型>――swap0<数据类型>(a, b);
void test01()
{
	int a = 30;
	int b = 40;
	swap0<int>(a, b);
}

//函数模板注意事项
//1 给出数据后自动判断数据类型
//2 T对应的数据类型必须一致
 //3 调用的函数体必须给出数据类型T


//函数模板与普通函数区别
//1 普通函数调用时可以发生自动类型转换（隐式类型转换）
//2 函数模板调用时，若是自动类型推导，不会发生自动类型转换（隐式类型转换）
//3 函数模板调用时，若是显示制定类型的方式，可以发生自动类型转换（隐式类型转换）

//自动类型转换：（简单了解）（由赋值给的变量决定）

//普通函数与函数模板重名时的调用规则
//1 优先调用可以实现的
//2 都可以实现时，优先调用普通函数
//3 函数模板可发生重载
//4 如果函数模板可以产生更好地匹配，优先调动函数模板
		//――当普通函数的数据类型可以被自动类型转换时，也会优先调用函数模板
//5 可通过空模板参数列表强制调用函数模板――函数名<>(形参)；


//函数模板的局限性
//1 不能将形参设置为数组
//2 自定义数据类型可能不能和正常数据类型一样操作
		//方法1 需要进行运算符重载
		//方法2 利用具体化对自定义类进行重载实现，只要遇到这个类优先就执行具体化的函数模板
		//	template<> 模板函数定义（类名 对象）
/*{
		对象.成员；
}*/