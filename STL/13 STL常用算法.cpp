#include<algorithm>//算法包含比较，遍历，交换，赋值，查找，修改等
#include<functional>//只包括几个在序列上面进行简单数学运算的模板函数
#include<numeric>//定义了几个模板类:accumulate/fill
#include<string>
#include<iostream>
#include<vector>
#include<ctime>//随机操作的头文件
#include<list>
#include<map>
using namespace std;


//常用遍历算法
/*
for_each(位置迭代器1，位置迭代器2，函数或仿函数);//函数是对每次遍历的元素操作方法。仿函数是要先重载(),调用――类名()

transform()――将一个容器中的元素在遍历过程中搬运到另一个容器
transform(源容器位置迭代器1，源容器位置迭代器2，目标容器起始位置迭代器，函数或函数对象);//函数或函数对象是对每个元素的操作方法
所有的目标容器要提前开辟空间
目标容器对象.resize(源容器.size());
*/

/*常用查找算法――前面都不带.
1.   find(位置迭代器1，位置迭代器2，要查找的元素或对象);//若有，返回该元素第一次出现的位置迭代器。若无，返回容器对象.end()
先判断if(返回的位置迭代器!= .end())
如果查找自定义数据类型，要重载==。让find的底层知道对比的自定义数据类型
class zidingyishujuleixing
{
public:
	zidingyishujuliexing(string name,int age){......}
	bool operator==(const person p)//比较、判断、查找等不需要改变原数据的操作，都加const
	{
		return this->name==p.name && this->age==p.age;
	}
	string name;
	int age;
}

2.  find_if(位置迭代器1，位置迭代器2，要满足的条件――谓词或匿名函数对象);//匿名函数对象――类名(),要重载()。若有满足谓词返回值条件，返回该元素第一次出现的位置迭代器。若无，返回容器对象.end()

3.  adjacent_find(位置迭代器1，位置迭代器2);//查找区间内相邻重复元素。若有，返回第一个重复元素的位置迭代器；若无，返回   .end();

4.  binary_search(位置迭代器1，位置迭代器2，要查找的元素或对象);//若有，返回true。若无，返会false。只能在有序序列中使用map/multimap/set/multiset/有序的其他容器

5.  count(位置迭代器1，位置迭代器2，要查找相同的元素或对象);//若为自定义数据类型，同样需要在类中重载==。
class zidingyishujuleixing
{
public:
	zidingyishujuliexing(string name,int age){......}
	bool operator==(const person p)//比较、判断、查找等不需要改变原数据的操作，都加const
	{
		return this->name==p.name && this->age==p.age;
	}
	string name;
	int age;
}

6.  count_if(位置迭代器1，位置迭代器2,谓词或匿名函数对象);//按要求查找满足谓词返回值条件对应元素个数。匿名函数对象――类名()，要重载()。
自定义数据类型也不用重载==
*/


/*常用排序算法
1.  sort(位置迭代器1，位置迭代器2，谓词);//谓词――类名()，满足谓词返回值条件作为排序条件，在类中制定规则。默认从小到大排序

2.  random_shuffle(位置迭代器1，位置迭代器2);//随机打乱区间内的顺序
	srand((unsigned int)time(NULL));//遇到随机就写它，需要包含头文件#include<ctime>

3.  merge(容器1位置迭代器，容器1位置迭代器，容器2位置迭代器，容器2位置迭代器，目标容器起始位置迭代器)；
两个容器必须都是从小到大,整合后的容器内也是按从小到大顺序排列的
需提前给目标容器分配空间――目标容器.resize(容器1.size()+容器2.size());

4.  reverse(位置迭代器1，位置迭代器2);//按前后位置对调元素
*/

/*常用拷贝和替换算法
1.  copy(源容器位置迭代器1，源容器位置迭代器2，目标容器起始位置迭代器）;
所有目的容器要预先开辟空间――目的容器.resize(源容器.size());

2.  replace(位置迭代器1，位置迭代器2，旧数据，新数据);//将所有一样的旧元素全换成新的

3.  replace_if(位置迭代器1，位置迭代器2，谓词，新数据);//满足谓词返回值条件的数全换成新数据

4.  swap(容器1，容器2);//容器类型要相同
*/

/*常用算数生成算法――头文件#include<numeric>
1.  accumulate(位置迭代器1，位置迭代器2，累加基值);//计算区间内的元素累加和

2.  fill(位置迭代器1，位置迭代器2，元素）;//对有前期余量空间的容器（默认填充为0），在后期可在区间内填充元素
*/


/*常用集合算法
1.  set_intersection(容器1起始位置迭代器，容器1结束位置迭代器，容器2起始位置迭代器，容器2结束位置迭代器，目标容器起始位置迭代器);//两容器必须是从小到大排序。有返回值，返回值为并集最后一个元素的位置迭代器
所有目标容器都要先开辟空间――目标容器.resize(min(容器1.size(),容器2.size());//交集空间最大也就是两容器中较小的空间

2.  set_union(容器1起始位置迭代器，容器1结束位置迭代器，容器2起始位置迭代器，容器2结束位置迭代器，目标容器起始位置迭代器);//两容器必须是从小到大排序。有返回值，返回值为并集最后一个元素的位置迭代器
所有目标容器都要先开辟空间――目标容器.resize(容器1.size() + 容器2.size());//并集空间最大也就是两容器空间之和
由于是最保险的空间大小，可能末尾会有默认填充为0的元素，所以
实际上的目标容器的结束迭代器为―― 容器<>::itreator end_pos = set_union(容器1起始位置迭代器，容器1结束位置迭代器，容器2起始位置迭代器，容器2结束位置迭代器，目标容器起始位置迭代器)

3.  set_difference(容器1起始位置迭代器，容器1结束位置迭代器，容器2起始位置迭代器，容器2结束位置迭代器，目标容器起始位置迭代器);//两容器必须是从小到大排序。容器1有，容器2没有的元素。
有返回值，返回值为并集最后一个元素的位置迭代器
所有目标容器都要先开辟空间――目标容器.resize(容器1.size() + 容器2.size());//并集空间最大也就是两容器空间之和
所有目标容器都要先开辟空间――目标容器.resize(max(容器1.size() , 容器2.size()));//差集空间最大也就是两容器更大的空间

*/










